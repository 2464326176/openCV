

# 计算机视觉

# 一.安装

环境：openCV mingw64 cmake

在ubuntu上学习一段时间感觉挺不方便的，还是windows比较方便操作点，整理了下windows的步骤，给大家分享下

## 1.1 mingw64 下载

地址：https://sourceforge.net/projects/mingw-w64/files/
MinGW-W64 GCC-8.1.0
    x86_64-posix-sjlj
    x86_64-posix-seh
    x86_64-win32-sjlj
    x86_64-win32-seh
    i686-posix-sjlj
    i686-posix-dwarf
    i686-win32-sjlj
    i686-win32-dwarf
可以看到有很多版本，这里要选择 x86_64-posix-sjlj
POSIX表示可移植操作系统接口(Portable Operating System Interface of UNIX，缩写为 POSIX )
seh 是新发明的，而 sjlj 则是古老的。seh 性能比较好，但不支持32位。sjlj 稳定性好，支持32位，兼容前面的平台。

## 1.2 camake 

https://cmake.org/

## 1.3 opencv源码：

https://github.com/opencv/opencv
详细的安装步骤：https://blog.huihut.com/2018/07/31/CompiledOpenCVWithMinGW64/

# 二、图像处理（imgproc. Image Processing）

## 图像滤波

抽出对象的特征作为图像识别的特征模式，消除图像数字化所混入的噪音；

方框滤波

均值滤波

高斯滤波

中值滤波

双边滤波





平滑处理

线性滤波：中值滤波、双边滤波

形态学滤波：腐蚀、膨胀、开运算、闭运算、形态学梯度、顶帽、黑帽

漫水填充

图像尺寸缩放

阈值化



## 图像变换

​	边缘检测：canny算子、sobel算子、Laplacian算子、scharr滤波器

​	边缘检测步骤：

canny算子步骤：

1.【第一步】滤波

边缘检测的算法主要是基于图像强度的一阶和二阶导数，但导数通常对噪声很敏感，因此必须采用滤波器来改善与噪声有关的边缘检测器的性能。常见的滤波方法主要有高斯滤波，即采用离散化的高斯函数产生一组归一化的高斯核，然后基于高斯核函数对图像灰度矩阵的每一点进行加权求和。
2.【第二步】增强
增强边缘的基础是确定图像各点邻域强度的变化值。增强算法可以将图像灰度点邻域强度值有显著变化的点凸显出来。在具体编程实现时，可通过计算梯度幅值来确定。
3.【第三步】检测
经过增强的图像，往往邻域中有很多点的梯度值比较大，而在特定的应用中，这些点并不是要找的边缘点，所以应该采用某种方法来对这些点进行取舍。实际工程中，常用的方法是通过阈值化方法来检测。
另外，需要注意，下文中讲到的Laplacian算子、sobel算子和 Scharr 算子都是带方向的，所以，示例中我们分别写了X方向、Y方向和最终合成的的效果图。



sobel算子步骤

1. sobel算子的基本概念
Sobel算子是一个主要用于边缘检测的离散微分算子( discrete differentiationoperator)。它结合了高斯平滑和微分求导，用来计算图像灰度函数的近似梯度。在图像的任何一点使用此算子，都将会产生对应的梯度矢量或是其法矢量。
2. sobel算子的计算过程
我们假设被作用图像为Ⅰ然后进行如下操作。(1）分别在x和y两个方向求导。
①水平变化:将Ⅰ与一个奇数大小的内核G进行卷积。比如，当内核大小为3时，G,的计算结果为:
[-1 0 +1G,--2 0 +2 * 1[-1 o +1]
垂直变化:将:I与一个奇数大小的内核进行卷积。比如，当内核大小为3时，计算结果为:
[-1 - 2+1G,=- o o o* i
+1 +2+1
(2）在图像的每一点，结合以上两个结果求出近似梯度:
G=G +G}
另外有时，也可用下面更简单的公式代替:
G=|G.l+/G,l

​	霍夫变换：

​	重映射

​	仿射变换

​	直方图均衡化





